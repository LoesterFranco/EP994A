XAS99 CROSS-ASSEMBLER   VERSION 1.7.0
**** **** ****     > test9900.asm
0001               * Erik Piehl (C) 2017 April
0002               * test9900.asm
0003               *
0004               * Test program sequences to test drive the TMS9900 VHDL core.
0005               *
0006               
0007               	IDT 'TEST9900'
0008      8300     WRKSP  EQU >8300
0009      8320     WRKSP2 EQU >8320
0010      8380     WRKSPI EQU >8380      * Interrupt workspace
0011 0000 8300         DATA WRKSP,BOOT   * RESET VECTOR
     0002 004Cr
0012 0004 8380         DATA WRKSPI,INTERRUPT
     0006 0334r
0013               BLWPTEST
0014 0008 8320         DATA WRKSP2,TEST2
     000A 02F6r
0015 000C BEEF         DATA >BEEF,>BEEF
     000E BEEF 
0016 0010 0000         DATA 0,0
     0012 0000 
0017 0014 0000         DATA 0,0,0,0,0,0,0,0
     0016 0000 
     0018 0000 
     001A 0000 
     001C 0000 
     001E 0000 
     0020 0000 
     0022 0000 
0018 0024 0000         DATA 0,0,0,0,0,0,0,0
     0026 0000 
     0028 0000 
     002A 0000 
     002C 0000 
     002E 0000 
     0030 0000 
     0032 0000 
0019 0034 0000         DATA 0,0,0,0,0,0
     0036 0000 
     0038 0000 
     003A 0000 
     003C 0000 
     003E 0000 
0020               * Here are the XOP vectors
0021 0040 8320         DATA WRKSP2,MYXOP0
     0042 0320r
0022 0044 8320         DATA WRKSP2,MYXOP1
     0046 032Ar
0023               
0024 0048 0040     COCTEST DATA >0040
0025 004A F000     CZCTEST DATA >F000
0026               
0027               *---------------------------------------------
0028               * Macro: printNumber <arg>
0029               * (would be xop <arg>,10 for the TMS9995 BB)
0030               *---------------------------------------------
0035               
0036               *---------------------------------------------
0037               * Macro: printCrLf
0038               *---------------------------------------------
0043               
0044               
0045               BOOT
0046 004C 0300  24   LIMI 2
     004E 0002 
0047               ; Test LDCR
0048 0050 020C  20   LI  R12,>550
     0052 0550 
0049 0054 058C  14   INC R12
0050 0056 060C  14   DEC R12
0051 0058 0203  20   LI  R3,>8155
     005A 8155 
0052 005C 3203  56   LDCR R3,8
0053 005E 02C4  12   STST R4
0054 0060 3603  64   STCR R3,8
0055 0062 0203  20   LI  R3,>0655
     0064 0655 
0056 0066 30C3  56   LDCR R3,3
0057 0068 02C4  12   STST R4
0058               
0059               ; Test byte operations with flags
0060 006A 04C0  14   CLR R0
0061 006C 04C1  14   CLR  R1
0062 006E 0702  14   SETO R2
0063 0070 0205  20   LI  R5,>7A9B
     0072 7A9B 
0064 0074 9805  38   CB  R5,@TESTK+1
     0076 0355r
0065               
0066 0078 0204  20   LI  R4,15
     007A 000F 
0067 007C 0205  20   LI  R5,0
     007E 0000 
0068 0080 0206  20   LI  R6,62000
     0082 F230 
0069 0084 3D44  128   DIV R4,R5
0070               
0071 0086 0204  20   LI  R4,10
     0088 000A 
0072 008A 0205  20   LI  R5,0
     008C 0000 
0073 008E 0206  20   LI  R6,100
     0090 0064 
0074 0092 3D44  128   DIV R4,R5
0075               
0076               
0077               ;  BL   @BYTECHECK ; classic99: 2000
0078               ;  LI  R0,>7F00
0079               ;  BL   @BYTECHECK ; classic99: C400
0080               ;  LI  R0,>8100
0081               ;  BL   @BYTECHECK ; classic99: 8000
0082               
0083 0094 0206  20   LI   R6,>0020
     0096 0020 
0084 0098 D806  38   MOVB R6,@>8304
     009A 8304 
0085 009C 02CA  12   STST  R10
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0088 009E D820  54   MOVB @>830D,@>8305
     00A0 830D 
     00A2 8305 
0089 00A4 02CA  12   STST  R10
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0092 00A6 C1E0  34   MOV @>8304,R7
     00A8 8304 
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0094               
0095               
0096               ; Test the X instruction
0097 00AA 020C  20   LI R12,>0400    ; CRU TEST address
     00AC 0400 
0098 00AE 04C9  14   CLR R9          ; ROM >05D2
0099 00B0 04C2  14   CLR R2          ; ROM >05EE
0100 00B2 D0A0  34   MOVB @TEST1+6,R2  ; ROM >05F0 kind of
     00B4 0350r
0101 00B6 0A42  56   SLA R2,4
0102 00B8 E242  18   SOC R2,R9
0103 00BA 0B69  56   SRC R9,6
0104 00BC 0269  22   ORI 9,>3012
     00BE 3012 
0105                 ; Here R9 becomes 3212: LDCR, C=8, TS=1, S=2
0106                 ; LDCR *R2,8
0107 00C0 0202  20   LI  R2,TEST1+8  ; TEST+1 contains 0C00
     00C2 0352r
0108 00C4 0489  12   X   9
0109               ;
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0111               ;
0112               ; EP 2019-01-15 Now that I am in the process of adding a cache, let's do a small loop.
0113               ; Without cache, the last instruction's iaq falling edge is at time 25,135 ns.
0114               ; With cache, the last instruction's falling edge is at 23,865 ns. 71 cache hits, each saving 2 clocks.
0115               ;
0116 00C6 0203  20   LI  R3,>8340
     00C8 8340 
0117 00CA 04C0  14   CLR R0
0118 00CC 0205  20   LI  R5,5
     00CE 0005 
0119               !
0120 00D0 CCC0  34   MOV R0,*R3+
0121 00D2 0605  14   DEC R5
0122 00D4 16FD  14   JNE -!
0123 00D6 C003  18   MOV R3,R0       ; Check timing of this MOV
0124 00D8 0205  20   LI  R5,1
     00DA 0001 
0125 00DC A143  18   A   R3,R5
0126               ; debug, problems with shift
0127 00DE 0202  20   LI  R2,2
     00E0 0002 
0128 00E2 0203  20   LI  R3,3
     00E4 0003 
0129 00E6 0200  20   LI  R0,4
     00E8 0004 
0130 00EA 0A22  56   SLA R2,2
0131 00EC 0A03  56   SLA R3,0
0132 00EE 0340  16   IDLE            ; wait for interrupt
0133               
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0137 00F0 04C0  14   CLR  R0
0138               ; Test a few instructions used by ROM
0139 00F2 0720  34   SETO @>8340
     00F4 8340 
0140 00F6 5820  54   SZCB @TEST1,@>8340
     00F8 034Ar
     00FA 8340 
0141               ; Test arithmetic greater than flag
0142 00FC D260  34   MOVB @TEST1+2,R9
     00FE 034Cr
0143 0100 1103  14   JLT  NAKS
0144 0102 0202  20   LI   R2,1
     0104 0001 
0145 0106 1001  14   JMP  !
0146               NAKS
0147 0108 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0148               !
0149 010A D260  34   MOVB @TEST1+4,R9
     010C 034Er
0150 010E 1101  14   JLT  !
0151 0110 10FB  14   JMP NAKS
0152 0112 0202  20 ! LI   R2,>11
     0114 0011 
0153               ; Test multiplication
0154 0116 0203  20   LI   R3,1
     0118 0001 
0155 011A 0204  20   LI   R4,2
     011C 0002 
0156 011E 3903  56   MPY  R3,R4
0157 0120 0203  20   LI   R3,>300
     0122 0300 
0158 0124 0204  20   LI   R4,>5000
     0126 5000 
0159 0128 3903  56   MPY  R3,R4
0160               ; Test immediate compare instruction - ; EP display top 4 bits of R1 in current VDP RAM location
0161 012A 0201  20   LI    R1,>8000
     012C 8000 
0162 012E 0941  56   SRL 	R1,4
0163 0130 0241  22   ANDI 	R1,>0F00
     0132 0F00 
0164 0134 0221  22   AI		R1,>3000	; Convert to ASCII
     0136 3000 
0165 0138 0281  22   CI		R1,>3A00
     013A 3A00 
0166 013C 02CA  12   STST  R10       ; FPGA C000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0169 013E 0201  20   LI    R1,>B000
     0140 B000 
0170 0142 0941  56   SRL 	R1,4
0171 0144 0241  22   ANDI 	R1,>0F00
     0146 0F00 
0172 0148 0221  22   AI		R1,>3000	; Convert to ASCII
     014A 3000 
0173 014C 0281  22   CI		R1,>3A00
     014E 3A00 
0174 0150 02CA  12   STST  R10       ; FPGA 0000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0177               ; Test compare instruction
0178 0152 0201  20   LI   R1,1
     0154 0001 
0179 0156 0202  20   LI   R2,2
     0158 0002 
0180 015A 8081  18   C    R1,R2		; classic99 - FPGA
0181 015C 02CA  12   STST R10			; 0000		  0000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0184 015E 8042  18   C    R2,R1
0185 0160 02CA  12   STST R10			; C000        C000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0188 0162 8041  18   C	   R1,R1
0189 0164 02CA  12   STST R10			; 2000        2000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0192 0166 0203  20   LI   R3,>8000
     0168 8000 
0193 016A 80C1  18   C    R1,R3		; 4000		  4000
0194 016C 02CA  12   STST R10
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0197 016E 0704  14   SETO  R4
0198 0170 80C4  18   C    R4,R3
0199 0172 02CA  12   STST R10  		; C000        C000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0202               
0203               ; test subtract instruction
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0205 0174 C142  18   MOV  R2,R5
0206 0176 6141  18   S    R1,R5		; classic99 - FPGA
0207 0178 02CA  12   STST R10			; D000		  0000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0210 017A C141  18   MOV  R1,R5
0211 017C 6142  18   S    R2,R5
0212 017E 02CA  12   STST R10			; 8000        D800
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0215 0180 C141  18   MOV  R1,R5
0216 0182 6141  18   S	   R1,R5
0217 0184 02CA  12   STST R10			; 3000        2000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0220 0186 0203  20   LI   R3,>8000
     0188 8000 
0221 018A C143  18   MOV  R3,R5
0222 018C 6141  18   S    R1,R5		; D800		  4000
0223 018E 02CA  12   STST R10
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0226 0190 0704  14   SETO  R4
0227 0192 C143  18   MOV  R3,R5
0228 0194 6144  18   S    R4,R5
0229 0196 02CA  12   STST R10  		; 8000        D000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0232               
0233               
0234 0198 0420  54   BLWP @BLWPTEST
     019A 0008r
0235 019C 020C  20   LI  R12,>0240
     019E 0240 
0236 01A0 1D00  20   SBO 0          * debug marker
0237 01A2 0202  20   LI  R2,>1
     01A4 0001 
0238 01A6 288C  18   XOR R12,R2
0239 01A8 20A0  38   COC @COCTEST,R2
     01AA 0048r
0240 01AC 1301  14   JEQ !
0241 01AE 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0242 01B0 24A0  38 ! CZC @CZCTEST,R2
     01B2 004Ar
0243 01B4 1301  14   JEQ !
0244 01B6 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0245               !
0246 01B8 1D00  20   SBO 0
0247 01BA 1E01  20   SBZ 1
0248 01BC 1D02  20   SBO 2
0249 01BE 1EFF  20   SBZ -1
0250 01C0 1F00  20   TB  0
0251 01C2 1301  14   JEQ GOODO1
0252 01C4 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0253               GOODO1
0254 01C6 1F01  20   TB  1
0255 01C8 1601  14   JNE GOODO2
0256 01CA 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0257               GOODO2:
0258 01CC 0200  20   LI  R0,>3333
     01CE 3333 
0259 01D0 2C20  64   XOP @>BEEF,0
     01D2 BEEF 
0260 01D4 0200  20   LI  R0,>5555
     01D6 5555 
0261 01D8 2C60  64   XOP @>0011,1
     01DA 0011 
0262               * Test LDCR
0263 01DC 020C  20   LI  R12,>550
     01DE 0550 
0264 01E0 0203  20   LI  R3,>0055
     01E2 0055 
0265 01E4 3003  56   LDCR R3,0
0266 01E6 3243  56   LDCR R3,9
0267 01E8 0203  20   LI   R3,6
     01EA 0006 
0268 01EC 0A83  56   SLA  R3,8
0269 01EE 30C3  56   LDCR R3,3
0270 01F0 04CC  14   CLR R12
0271 01F2 0208  20   LI   R8,>12   * Low byte to 12
     01F4 0012 
0272 01F6 3608  64   STCR R8,8
0273 01F8 3409  64   STCR R9,0
0274 01FA 0288  22   CI   R8,>7912
     01FC 7912 
0275 01FE 1301  14   JEQ  !
0276 0200 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0277 0202 0289  22 ! CI   R9,>A079
     0204 A079 
0278 0206 1301  14   JEQ  !
0279 0208 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0280               !
0281 020A 0203  20   LI  R3,>8340    ** write to 8306 data 8340 1000001101000000
     020C 8340 
0282 020E 0207  20   LI  R7,>8350
     0210 8350 
0283 0212 0201  20   LI  R1,>0123
     0214 0123 
0284 0216 0202  20   LI  R2,>4567
     0218 4567 
0285 021A 0204  20   LI  R4,>89AB
     021C 89AB 
0286 021E C4C1  30   MOV R1,*R3
0287 0220 C8C2  38   MOV R2,@2(R3)
     0222 0002 
0288 0224 C8C4  38   MOV R4,@4(R3)
     0226 0004 
0289 0228 04E3  34   CLR @6(R3)
     022A 0006 
0290 022C DDF3  42   MOVB *R3+,*R7+
0291 022E DDF3  42   MOVB *R3+,*R7+
0292 0230 DDF3  42   MOVB *R3+,*R7+
0293 0232 DDF3  42   MOVB *R3+,*R7+
0294 0234 CDF3  46   MOV  *R3+,*R7+
0295 0236 D820  54   MOVB @>8303,@>8350
     0238 8303 
     023A 8350 
0296 023C 0203  20   LI   R3,>8340
     023E 8340 
0297               * Test byte operations
0298 0240 D804  38   MOVB R4,@>8340
     0242 8340 
0299 0244 D802  38   MOVB R2,@>8341
     0246 8341 
0300 0248 C4C1  30   MOV  R1,*R3   * Restore
0301 024A D4C4  30   MOVB R4,*R3
0302 024C BCC1  32   AB   R1,*R3+
0303 024E B4C1  30   AB   R1,*R3
0304 0250 0223  22   AI   R3,-1
     0252 FFFF 
0305 0254 D073  28   MOVB *R3+,R1
0306 0256 D053  26   MOVB *R3,R1
0307 0258 0603  14   DEC  R3
0308               
0309 025A 04D3  26   CLR *R3
0310 025C 0204  20   LI  R4,>8350
     025E 8350 
0311 0260 0202  20   LI  R2,2
     0262 0002 
0312 0264 CD33  46   MOV *R3+,*R4+
0313 0266 0644  14   DECT R4
0314 0268 AD02  34   A   R2,*R4+
0315 026A 6802  38   S   R2,@>8350
     026C 8350 
0316 026E 0283  22   CI  R3,>8342
     0270 8342 
0317 0272 1301  14   JEQ GOOD1
0318 0274 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0319               GOOD1:
0320 0276 0201  20   LI  R1,>4444
     0278 4444 
0321 027A C801  38   MOV R1,@>8360
     027C 8360 
0322 027E C820  54   MOV @>8360,@>8350
     0280 8360 
     0282 8350 
0323 0284 8060  34   C   @>8350,R1
     0286 8350 
0324 0288 1301  14   JEQ GOOD2
0325 028A 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0326               GOOD2:
0327 028C 0200  20   LI  R0,>1234
     028E 1234 
0328 0290 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0329               BACK
0330 0292 06A0  32   BL    @SUBROUTINE
     0294 02F0r
0331 0296 04C1  14   CLR R1
0332 0298 04E3  34   CLR   @4(R3)
     029A 0004 
0333 029C 0723  34   SETO  @6(R3)
     029E 0006 
0334 02A0 04E0  34   CLR   @>8348
     02A2 8348 
0335 02A4 0713  26   SETO  *R3
0336 02A6 04F3  30   CLR   *R3+
0337 02A8 04F3  30   CLR   *R3+
0338 02AA 04F3  30   CLR   *R3+
0339 02AC 0502  16   NEG R2
0340 02AE CCC2  34   MOV R2,*R3+
0341 02B0 10F0  14   JMP BACK
0342 02B2 0502  16   NEG R2
0343 02B4 0202  20   LI R2, >8002
     02B6 8002 
0344 02B8 0502  16   NEG R2
0345 02BA 0502  16   NEG R2
0346 02BC 05C3  14   INCT R3
0347 02BE C143  18   MOV R3,R5
0348 02C0 0585  14   INC R5
0349 02C2 0605  14   DEC R5
0350 02C4 06C5  14   SWPB R5
0351 02C6 0545  14   INV R5
0352 02C8 0713  26   SETO *R3
0353 02CA 0745  18   ABS R5
0354 02CC 0505  16   NEG R5
0355 02CE 0200  20   LI  R0,>1234    ** write to 8300 data 1234 0001001000110100
     02D0 1234 
0356 02D2 0201  20   LI  R1,1        ** write to 8302 data 0001 0000000000000001
     02D4 0001 
0357 02D6 C4C0  30   MOV R0,*R3      ** write to 8340 data 1234 0001001000110100
0358 02D8 C0B3  30   MOV *R3+,R2     ** write to 8306 data 8342 1000001101000010
0359               *                 ** write to 8304 data 1234 0001001000110100
0360 02DA A081  18   A   R1,R2       ** write to 8304 data 1235 0001001000110101
0361 02DC C202  18   MOV R2,R8       ** write to 8310 data 1235 0001001000110101
0362 02DE C4C1  30   MOV R1,*R3      ** write to 8342 data 0001 0000000000000001
0363 02E0 A4C1  30   A   R1,*R3      ** write to 8342 data 0002 0000000000000010
0364 02E2 C820  54   MOV @>4,@>8344
     02E4 0004 
     02E6 8344 
0365 02E8 06A0  32   BL  @SUBROUTINE
     02EA 02F0r
0366 02EC 0460  28   B   @BOOT
     02EE 004Cr
0367               
0368               SUBROUTINE
0369 02F0 0204  20   LI  R4,123
     02F2 007B 
0370 02F4 045B  20   RT
0371               
0372               * Thus source modes Rx, *Rx, *Rx+, @addr work
0373               * Destination modes Rx and *Rx work
0374               *   Also destination mode @addr works for MOV but not other instructions
0375               * First iteration of MOV @>4,@>8344 takes 3375-2915=460ns from iaq to iaq
0376               
0377               TEST2
0378 02F6 03A0  16   CKON
0379 02F8 02A0  12   STWP R0
0380 02FA 0202  20   LI   R2,4
     02FC 0004 
0381 02FE C0C2  18   MOV  R2,R3
0382 0300 0583  14   INC  R3
0383 0302 6083  18   S    R3,R2
0384 0304 02C1  12   STST R1
0385 0306 0200  20   LI  R0,>0004
     0308 0004 
0386 030A C040  18   MOV R0,R1
0387 030C 0202  20   LI R2,-4
     030E FFFC 
0388 0310 C0C0  18   MOV R0,R3
0389 0312 0204  20   LI  R4,-4
     0314 FFFC 
0390 0316 0A81  56   SLA R1,8
0391 0318 0812  56   SRA R2,1
0392 031A 0B43  56   SRC R3,4
0393 031C 0914  56   SRL R4,1
0394 031E 0380  18   RTWP
0395               
0396               MYXOP0
0397 0320 020C  20   LI R12,>0100
     0322 0100 
0398 0324 02C1  12   STST R1
0399 0326 1D00  20   SBO 0
0400 0328 0380  18   RTWP
0401               MYXOP1
0402 032A 020C  20   LI R12,>0100
     032C 0100 
0403 032E 02C1  12   STST R1
0404 0330 1D01  20   SBO 1
0405 0332 0380  18   RTWP
0406               
0407               INTERRUPT
0408 0334 0200  20   LI  R0,>4455
     0336 4455 
0409 0338 0201  20   LI  R1,>6677
     033A 6677 
0410 033C 02CA  12   STST R10
0411 033E 0380  18   RTWP
0412               
0413               BYTECHECK:
0414 0340 D040  18   MOVB R0,R1
0415 0342 02CA  12   STST  R10      ; classic99: C400
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0419 0344 D080  18   MOVB R0,R2
0420 0346 02CA  12   STST  R10       ; classic99: C400
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0424 0348 045B  20   RT
0425               
0426               TEST1
0427 034A 2080       DATA >2080
0428 034C 4000       DATA >4000
0429 034E A000       DATA >A000
0430 0350 0800       DATA >0800
0431 0352 0C00       DATA >0C00
0432               TESTK
0433 0354 8090       DATA >8090
0434               SLAST  END  BOOT
