XAS99 CROSS-ASSEMBLER   VERSION 1.7.0
**** **** ****     > test9900.asm
0001               * Erik Piehl (C) 2017 April
0002               * test9900.asm
0003               *
0004               * Test program sequences to test drive the TMS9900 VHDL core.
0005               *
0006               
0007               	IDT 'TEST9900'
0008      8300     WRKSP  EQU >8300
0009      8320     WRKSP2 EQU >8320
0010      8380     WRKSPI EQU >8380      * Interrupt workspace
0011 0000 8300         DATA WRKSP,BOOT   * RESET VECTOR
     0002 004Cr
0012 0004 8380         DATA WRKSPI,INTERRUPT
     0006 0330r
0013               BLWPTEST
0014 0008 8320         DATA WRKSP2,TEST2
     000A 02F2r
0015 000C BEEF         DATA >BEEF,>BEEF
     000E BEEF 
0016 0010 0000         DATA 0,0
     0012 0000 
0017 0014 0000         DATA 0,0,0,0,0,0,0,0
     0016 0000 
     0018 0000 
     001A 0000 
     001C 0000 
     001E 0000 
     0020 0000 
     0022 0000 
0018 0024 0000         DATA 0,0,0,0,0,0,0,0
     0026 0000 
     0028 0000 
     002A 0000 
     002C 0000 
     002E 0000 
     0030 0000 
     0032 0000 
0019 0034 0000         DATA 0,0,0,0,0,0
     0036 0000 
     0038 0000 
     003A 0000 
     003C 0000 
     003E 0000 
0020               * Here are the XOP vectors
0021 0040 8320         DATA WRKSP2,MYXOP0
     0042 031Cr
0022 0044 8320         DATA WRKSP2,MYXOP1
     0046 0326r
0023               
0024 0048 0040     COCTEST DATA >0040
0025 004A F000     CZCTEST DATA >F000
0026               
0027               *---------------------------------------------
0028               * Macro: printNumber <arg>
0029               * (would be xop <arg>,10 for the TMS9995 BB)
0030               *---------------------------------------------
0035               
0036               *---------------------------------------------
0037               * Macro: printCrLf
0038               *---------------------------------------------
0043               
0044               
0045               BOOT
0046 004C 0300  24   LIMI 2
     004E 0002 
0047               ; Test LDCR
0048 0050 020C  20   LI  R12,>550
     0052 0550 
0049 0054 058C  14   INC R12
0050 0056 060C  14   DEC R12
0051 0058 0203  20   LI  R3,>8155
     005A 8155 
0052 005C 3203  56   LDCR R3,8
0053 005E 3603  64   STCR R3,8
0054 0060 0203  20   LI  R3,>0655
     0062 0655 
0055 0064 30C3  56   LDCR R3,3
0056               
0057               ; Test byte operations with flags
0058 0066 04C0  14   CLR R0
0059 0068 04C1  14   CLR  R1
0060 006A 0702  14   SETO R2
0061 006C 0205  20   LI  R5,>7A9B
     006E 7A9B 
0062 0070 9805  38   CB  R5,@TESTK+1
     0072 0351r
0063               
0064 0074 0204  20   LI  R4,15
     0076 000F 
0065 0078 0205  20   LI  R5,0
     007A 0000 
0066 007C 0206  20   LI  R6,62000
     007E F230 
0067 0080 3D44  128   DIV R4,R5
0068               
0069 0082 0204  20   LI  R4,10
     0084 000A 
0070 0086 0205  20   LI  R5,0
     0088 0000 
0071 008A 0206  20   LI  R6,100
     008C 0064 
0072 008E 3D44  128   DIV R4,R5
0073               
0074               
0075               ;  BL   @BYTECHECK ; classic99: 2000
0076               ;  LI  R0,>7F00
0077               ;  BL   @BYTECHECK ; classic99: C400
0078               ;  LI  R0,>8100
0079               ;  BL   @BYTECHECK ; classic99: 8000
0080               
0081 0090 0206  20   LI   R6,>0020
     0092 0020 
0082 0094 D806  38   MOVB R6,@>8304
     0096 8304 
0083 0098 02CA  12   STST  R10
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0086 009A D820  54   MOVB @>830D,@>8305
     009C 830D 
     009E 8305 
0087 00A0 02CA  12   STST  R10
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0090 00A2 C1E0  34   MOV @>8304,R7
     00A4 8304 
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0092               
0093               
0094               ; Test the X instruction
0095 00A6 020C  20   LI R12,>0400    ; CRU TEST address
     00A8 0400 
0096 00AA 04C9  14   CLR R9          ; ROM >05D2
0097 00AC 04C2  14   CLR R2          ; ROM >05EE
0098 00AE D0A0  34   MOVB @TEST1+6,R2  ; ROM >05F0 kind of
     00B0 034Cr
0099 00B2 0A42  56   SLA R2,4
0100 00B4 E242  18   SOC R2,R9
0101 00B6 0B69  56   SRC R9,6
0102 00B8 0269  22   ORI 9,>3012
     00BA 3012 
0103                 ; Here R9 becomes 3212: LDCR, C=8, TS=1, S=2
0104                 ; LDCR *R2,8
0105 00BC 0202  20   LI  R2,TEST1+8  ; TEST+1 contains 0C00
     00BE 034Er
0106 00C0 0489  12   X   9
0107               ;
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0109               ;
0110               ; EP 2019-01-15 Now that I am in the process of adding a cache, let's do a small loop.
0111               ; Without cache, the last instruction's iaq falling edge is at time 25,135 ns.
0112               ; With cache, the last instruction's falling edge is at 23,865 ns. 71 cache hits, each saving 2 clocks.
0113               ;
0114 00C2 0203  20   LI  R3,>8340
     00C4 8340 
0115 00C6 04C0  14   CLR R0
0116 00C8 0205  20   LI  R5,5
     00CA 0005 
0117               !
0118 00CC CCC0  34   MOV R0,*R3+
0119 00CE 0605  14   DEC R5
0120 00D0 16FD  14   JNE -!
0121 00D2 C003  18   MOV R3,R0       ; Check timing of this MOV
0122 00D4 0205  20   LI  R5,1
     00D6 0001 
0123 00D8 A143  18   A   R3,R5
0124               ; debug, problems with shift
0125 00DA 0202  20   LI  R2,2
     00DC 0002 
0126 00DE 0203  20   LI  R3,3
     00E0 0003 
0127 00E2 0200  20   LI  R0,4
     00E4 0004 
0128 00E6 0A22  56   SLA R2,2
0129 00E8 0A03  56   SLA R3,0
0130 00EA 0340  16   IDLE            ; wait for interrupt
0131               
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0135 00EC 04C0  14   CLR  R0
0136               ; Test a few instructions used by ROM
0137 00EE 0720  34   SETO @>8340
     00F0 8340 
0138 00F2 5820  54   SZCB @TEST1,@>8340
     00F4 0346r
     00F6 8340 
0139               ; Test arithmetic greater than flag
0140 00F8 D260  34   MOVB @TEST1+2,R9
     00FA 0348r
0141 00FC 1103  14   JLT  NAKS
0142 00FE 0202  20   LI   R2,1
     0100 0001 
0143 0102 1001  14   JMP  !
0144               NAKS
0145 0104 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0146               !
0147 0106 D260  34   MOVB @TEST1+4,R9
     0108 034Ar
0148 010A 1101  14   JLT  !
0149 010C 10FB  14   JMP NAKS
0150 010E 0202  20 ! LI   R2,>11
     0110 0011 
0151               ; Test multiplication
0152 0112 0203  20   LI   R3,1
     0114 0001 
0153 0116 0204  20   LI   R4,2
     0118 0002 
0154 011A 3903  56   MPY  R3,R4
0155 011C 0203  20   LI   R3,>300
     011E 0300 
0156 0120 0204  20   LI   R4,>5000
     0122 5000 
0157 0124 3903  56   MPY  R3,R4
0158               ; Test immediate compare instruction - ; EP display top 4 bits of R1 in current VDP RAM location
0159 0126 0201  20   LI    R1,>8000
     0128 8000 
0160 012A 0941  56   SRL 	R1,4
0161 012C 0241  22   ANDI 	R1,>0F00
     012E 0F00 
0162 0130 0221  22   AI		R1,>3000	; Convert to ASCII
     0132 3000 
0163 0134 0281  22   CI		R1,>3A00
     0136 3A00 
0164 0138 02CA  12   STST  R10       ; FPGA C000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0167 013A 0201  20   LI    R1,>B000
     013C B000 
0168 013E 0941  56   SRL 	R1,4
0169 0140 0241  22   ANDI 	R1,>0F00
     0142 0F00 
0170 0144 0221  22   AI		R1,>3000	; Convert to ASCII
     0146 3000 
0171 0148 0281  22   CI		R1,>3A00
     014A 3A00 
0172 014C 02CA  12   STST  R10       ; FPGA 0000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0175               ; Test compare instruction
0176 014E 0201  20   LI   R1,1
     0150 0001 
0177 0152 0202  20   LI   R2,2
     0154 0002 
0178 0156 8081  18   C    R1,R2		; classic99 - FPGA
0179 0158 02CA  12   STST R10			; 0000		  0000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0182 015A 8042  18   C    R2,R1
0183 015C 02CA  12   STST R10			; C000        C000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0186 015E 8041  18   C	   R1,R1
0187 0160 02CA  12   STST R10			; 2000        2000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0190 0162 0203  20   LI   R3,>8000
     0164 8000 
0191 0166 80C1  18   C    R1,R3		; 4000		  4000
0192 0168 02CA  12   STST R10
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0195 016A 0704  14   SETO  R4
0196 016C 80C4  18   C    R4,R3
0197 016E 02CA  12   STST R10  		; C000        C000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0200               
0201               ; test subtract instruction
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0203 0170 C142  18   MOV  R2,R5
0204 0172 6141  18   S    R1,R5		; classic99 - FPGA
0205 0174 02CA  12   STST R10			; D000		  0000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0208 0176 C141  18   MOV  R1,R5
0209 0178 6142  18   S    R2,R5
0210 017A 02CA  12   STST R10			; 8000        D800
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0213 017C C141  18   MOV  R1,R5
0214 017E 6141  18   S	   R1,R5
0215 0180 02CA  12   STST R10			; 3000        2000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0218 0182 0203  20   LI   R3,>8000
     0184 8000 
0219 0186 C143  18   MOV  R3,R5
0220 0188 6141  18   S    R1,R5		; D800		  4000
0221 018A 02CA  12   STST R10
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0224 018C 0704  14   SETO  R4
0225 018E C143  18   MOV  R3,R5
0226 0190 6144  18   S    R4,R5
0227 0192 02CA  12   STST R10  		; 8000        D000
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0230               
0231               
0232 0194 0420  54   BLWP @BLWPTEST
     0196 0008r
0233 0198 020C  20   LI  R12,>0240
     019A 0240 
0234 019C 1D00  20   SBO 0          * debug marker
0235 019E 0202  20   LI  R2,>1
     01A0 0001 
0236 01A2 288C  18   XOR R12,R2
0237 01A4 20A0  38   COC @COCTEST,R2
     01A6 0048r
0238 01A8 1301  14   JEQ !
0239 01AA 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0240 01AC 24A0  38 ! CZC @CZCTEST,R2
     01AE 004Ar
0241 01B0 1301  14   JEQ !
0242 01B2 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0243               !
0244 01B4 1D00  20   SBO 0
0245 01B6 1E01  20   SBZ 1
0246 01B8 1D02  20   SBO 2
0247 01BA 1EFF  20   SBZ -1
0248 01BC 1F00  20   TB  0
0249 01BE 1301  14   JEQ GOODO1
0250 01C0 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0251               GOODO1
0252 01C2 1F01  20   TB  1
0253 01C4 1601  14   JNE GOODO2
0254 01C6 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0255               GOODO2:
0256 01C8 0200  20   LI  R0,>3333
     01CA 3333 
0257 01CC 2C20  64   XOP @>BEEF,0
     01CE BEEF 
0258 01D0 0200  20   LI  R0,>5555
     01D2 5555 
0259 01D4 2C60  64   XOP @>0011,1
     01D6 0011 
0260               * Test LDCR
0261 01D8 020C  20   LI  R12,>550
     01DA 0550 
0262 01DC 0203  20   LI  R3,>0055
     01DE 0055 
0263 01E0 3003  56   LDCR R3,0
0264 01E2 3243  56   LDCR R3,9
0265 01E4 0203  20   LI   R3,6
     01E6 0006 
0266 01E8 0A83  56   SLA  R3,8
0267 01EA 30C3  56   LDCR R3,3
0268 01EC 04CC  14   CLR R12
0269 01EE 0208  20   LI   R8,>12   * Low byte to 12
     01F0 0012 
0270 01F2 3608  64   STCR R8,8
0271 01F4 3409  64   STCR R9,0
0272 01F6 0288  22   CI   R8,>7912
     01F8 7912 
0273 01FA 1301  14   JEQ  !
0274 01FC 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0275 01FE 0289  22 ! CI   R9,>A079
     0200 A079 
0276 0202 1301  14   JEQ  !
0277 0204 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0278               !
0279 0206 0203  20   LI  R3,>8340    ** write to 8306 data 8340 1000001101000000
     0208 8340 
0280 020A 0207  20   LI  R7,>8350
     020C 8350 
0281 020E 0201  20   LI  R1,>0123
     0210 0123 
0282 0212 0202  20   LI  R2,>4567
     0214 4567 
0283 0216 0204  20   LI  R4,>89AB
     0218 89AB 
0284 021A C4C1  30   MOV R1,*R3
0285 021C C8C2  38   MOV R2,@2(R3)
     021E 0002 
0286 0220 C8C4  38   MOV R4,@4(R3)
     0222 0004 
0287 0224 04E3  34   CLR @6(R3)
     0226 0006 
0288 0228 DDF3  42   MOVB *R3+,*R7+
0289 022A DDF3  42   MOVB *R3+,*R7+
0290 022C DDF3  42   MOVB *R3+,*R7+
0291 022E DDF3  42   MOVB *R3+,*R7+
0292 0230 CDF3  46   MOV  *R3+,*R7+
0293 0232 D820  54   MOVB @>8303,@>8350
     0234 8303 
     0236 8350 
0294 0238 0203  20   LI   R3,>8340
     023A 8340 
0295               * Test byte operations
0296 023C D804  38   MOVB R4,@>8340
     023E 8340 
0297 0240 D802  38   MOVB R2,@>8341
     0242 8341 
0298 0244 C4C1  30   MOV  R1,*R3   * Restore
0299 0246 D4C4  30   MOVB R4,*R3
0300 0248 BCC1  32   AB   R1,*R3+
0301 024A B4C1  30   AB   R1,*R3
0302 024C 0223  22   AI   R3,-1
     024E FFFF 
0303 0250 D073  28   MOVB *R3+,R1
0304 0252 D053  26   MOVB *R3,R1
0305 0254 0603  14   DEC  R3
0306               
0307 0256 04D3  26   CLR *R3
0308 0258 0204  20   LI  R4,>8350
     025A 8350 
0309 025C 0202  20   LI  R2,2
     025E 0002 
0310 0260 CD33  46   MOV *R3+,*R4+
0311 0262 0644  14   DECT R4
0312 0264 AD02  34   A   R2,*R4+
0313 0266 6802  38   S   R2,@>8350
     0268 8350 
0314 026A 0283  22   CI  R3,>8342
     026C 8342 
0315 026E 1301  14   JEQ GOOD1
0316 0270 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0317               GOOD1:
0318 0272 0201  20   LI  R1,>4444
     0274 4444 
0319 0276 C801  38   MOV R1,@>8360
     0278 8360 
0320 027A C820  54   MOV @>8360,@>8350
     027C 8360 
     027E 8350 
0321 0280 8060  34   C   @>8350,R1
     0282 8350 
0322 0284 1301  14   JEQ GOOD2
0323 0286 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0324               GOOD2:
0325 0288 0200  20   LI  R0,>1234
     028A 1234 
0326 028C 0381       DATA >0381    ** RTWP but illegal on TMS9995, will get stuck
0327               BACK
0328 028E 06A0  32   BL    @SUBROUTINE
     0290 02ECr
0329 0292 04C1  14   CLR R1
0330 0294 04E3  34   CLR   @4(R3)
     0296 0004 
0331 0298 0723  34   SETO  @6(R3)
     029A 0006 
0332 029C 04E0  34   CLR   @>8348
     029E 8348 
0333 02A0 0713  26   SETO  *R3
0334 02A2 04F3  30   CLR   *R3+
0335 02A4 04F3  30   CLR   *R3+
0336 02A6 04F3  30   CLR   *R3+
0337 02A8 0502  16   NEG R2
0338 02AA CCC2  34   MOV R2,*R3+
0339 02AC 10F0  14   JMP BACK
0340 02AE 0502  16   NEG R2
0341 02B0 0202  20   LI R2, >8002
     02B2 8002 
0342 02B4 0502  16   NEG R2
0343 02B6 0502  16   NEG R2
0344 02B8 05C3  14   INCT R3
0345 02BA C143  18   MOV R3,R5
0346 02BC 0585  14   INC R5
0347 02BE 0605  14   DEC R5
0348 02C0 06C5  14   SWPB R5
0349 02C2 0545  14   INV R5
0350 02C4 0713  26   SETO *R3
0351 02C6 0745  18   ABS R5
0352 02C8 0505  16   NEG R5
0353 02CA 0200  20   LI  R0,>1234    ** write to 8300 data 1234 0001001000110100
     02CC 1234 
0354 02CE 0201  20   LI  R1,1        ** write to 8302 data 0001 0000000000000001
     02D0 0001 
0355 02D2 C4C0  30   MOV R0,*R3      ** write to 8340 data 1234 0001001000110100
0356 02D4 C0B3  30   MOV *R3+,R2     ** write to 8306 data 8342 1000001101000010
0357               *                 ** write to 8304 data 1234 0001001000110100
0358 02D6 A081  18   A   R1,R2       ** write to 8304 data 1235 0001001000110101
0359 02D8 C202  18   MOV R2,R8       ** write to 8310 data 1235 0001001000110101
0360 02DA C4C1  30   MOV R1,*R3      ** write to 8342 data 0001 0000000000000001
0361 02DC A4C1  30   A   R1,*R3      ** write to 8342 data 0002 0000000000000010
0362 02DE C820  54   MOV @>4,@>8344
     02E0 0004 
     02E2 8344 
0363 02E4 06A0  32   BL  @SUBROUTINE
     02E6 02ECr
0364 02E8 0460  28   B   @BOOT
     02EA 004Cr
0365               
0366               SUBROUTINE
0367 02EC 0204  20   LI  R4,123
     02EE 007B 
0368 02F0 045B  20   RT
0369               
0370               * Thus source modes Rx, *Rx, *Rx+, @addr work
0371               * Destination modes Rx and *Rx work
0372               *   Also destination mode @addr works for MOV but not other instructions
0373               * First iteration of MOV @>4,@>8344 takes 3375-2915=460ns from iaq to iaq
0374               
0375               TEST2
0376 02F2 03A0  16   CKON
0377 02F4 02A0  12   STWP R0
0378 02F6 0202  20   LI   R2,4
     02F8 0004 
0379 02FA C0C2  18   MOV  R2,R3
0380 02FC 0583  14   INC  R3
0381 02FE 6083  18   S    R3,R2
0382 0300 02C1  12   STST R1
0383 0302 0200  20   LI  R0,>0004
     0304 0004 
0384 0306 C040  18   MOV R0,R1
0385 0308 0202  20   LI R2,-4
     030A FFFC 
0386 030C C0C0  18   MOV R0,R3
0387 030E 0204  20   LI  R4,-4
     0310 FFFC 
0388 0312 0A81  56   SLA R1,8
0389 0314 0812  56   SRA R2,1
0390 0316 0B43  56   SRC R3,4
0391 0318 0914  56   SRL R4,1
0392 031A 0380  18   RTWP
0393               
0394               MYXOP0
0395 031C 020C  20   LI R12,>0100
     031E 0100 
0396 0320 02C1  12   STST R1
0397 0322 1D00  20   SBO 0
0398 0324 0380  18   RTWP
0399               MYXOP1
0400 0326 020C  20   LI R12,>0100
     0328 0100 
0401 032A 02C1  12   STST R1
0402 032C 1D01  20   SBO 1
0403 032E 0380  18   RTWP
0404               
0405               INTERRUPT
0406 0330 0200  20   LI  R0,>4455
     0332 4455 
0407 0334 0201  20   LI  R1,>6677
     0336 6677 
0408 0338 02CA  12   STST R10
0409 033A 0380  18   RTWP
0410               
0411               BYTECHECK:
0412 033C D040  18   MOVB R0,R1
0413 033E 02CA  12   STST  R10      ; classic99: C400
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0417 0340 D080  18   MOVB R0,R2
0418 0342 02CA  12   STST  R10       ; classic99: C400
0001               *	    BLWP	@PRINTS
0002               *  	  DATA	TXTCRLF
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0001               *			MOV		#1,@PRTR1P		; Store HEX value to print
0002               *			BLWP	@PRINTR1			; Go print R1
0422 0344 045B  20   RT
0423               
0424               TEST1
0425 0346 2080       DATA >2080
0426 0348 4000       DATA >4000
0427 034A A000       DATA >A000
0428 034C 0800       DATA >0800
0429 034E 0C00       DATA >0C00
0430               TESTK
0431 0350 8090       DATA >8090
0432               SLAST  END  BOOT
